# ゲームランチャーアプリ ver.3 開発ログ

## 1. 概要

本ドキュメントは、「ゲームランチャーアプリ ver.3」の新規開発にあたり、そのセットアップから機能実装、デバッグに至るまでの一連のプロセスを記録するものである。

開発は `要件定義書.md` および `仕様書.md` に基づいて進められた。

## 2. 初期セットアップ

アプリケーションの土台を構築するため、以下のセットアップ作業を実施した。

1.  **プロジェクト初期化**: `npm init` を実行し、`package.json` を生成。
2.  **依存関係のインストール**:
    -   `electron`, `typescript`: メインプロセス用
    -   `react`, `react-dom`, `vite`: レンダラープロセス（UI）用
    -   `jotai`: 状態管理ライブラリ
    -   `tailwindcss`, `postcss`, `autoprefixer`: スタイリング用
    -   `concurrently`, `cross-env`: 開発用ユーティリティ
3.  **プロジェクト構造**:
    -   Electronのメインプロセス関連ファイル (`main.ts`, `preload.ts`, `tsconfig.json`) をルートに配置。
    -   Vite + Reactで構成されるレンダラープロセスを `renderer` サブディレクトリに手動で構築。
    -   `package.json` に、開発 (`start`) と本番 (`start:prod`) 用のスクリプトを定義。

## 3. 機能実装

仕様書に基づき、以下の機能を順に実装した。

1.  **Steamゲームの自動検出**
    -   WindowsレジストリからSteamのインストールパスを取得。
    -   `libraryfolders.vdf` をパースして、ゲームがインストールされている全ライブラリのパスを特定。
    -   各ライブラリ内の `appmanifest_*.acf` ファイルをスキャンし、`AppID` とゲーム名 (`name`) を抽出。

2.  **UIの基本実装**
    -   レンダラープロセス (`App.tsx`) でIPCを介してゲームリストを取得。
    -   Tailwind CSSを使い、ゲームカバーをレスポンシブなグリッドレイアウトで表示。
    -   カバーアートにマウスホバーすると拡大するエフェクトを実装。

3.  **設定ページの作成**
    -   Steam Web APIキーを入力・保存するためのUI (`Settings.tsx`) を作成。
    -   `electron-store` を導入し、入力されたAPIキーを永続的に保存する仕組みをメインプロセスに実装。
    -   ライブラリ画面と設定ページを切り替えるための簡易的な画面遷移ロジックを実装。

4.  **Steam Web APIとの連携**
    -   設定ページで保存されたAPIキーを使い、Steam Web API (`appdetails`) にリクエストを送信。
    -   各ゲームのカバーアート (`header_image`) とプロモーションビデオ (`movies`) のURLを取得し、ゲームオブジェクトに格納。

5.  **手動でのゲーム追加機能**
    -   ゲームタイトル、実行ファイルパス、カバーアート画像を選択するモーダルUI (`AddGameModal.tsx`) を作成。
    -   メインプロセスにファイル選択ダイアログを開くIPCハンドラ (`open-file-dialog`) を実装。
    -   ゲーム情報を保存するIPCハンドラ (`save-manual-game`) を実装。
        -   選択されたカバーアートはアプリの `userData` ディレクトリにコピーして管理。
        -   ゲーム情報は `electron-store` を使ってJSON形式で永続化。

6.  **ゲーム起動機能**
    -   ゲームアイテムのクリックをトリガーとするIPCハンドラ (`launch-game`) を実装。
    -   Steamゲームは `shell.openExternal` を使って `steam://run/<AppID>` を実行。
    -   手動追加したゲームは `child_process.exec` を使って、そのゲームのディレクトリを作業ディレクトリ (`cwd`) として指定し、実行ファイルを起動。

7.  **動的背景の実装**
    -   マウスホバーで選択されたゲームにプロモーションビデオのURLが存在する場合、`<video>` タグを使って背景で再生。
    -   ビデオが存在しない場合は、カバーアートを静止画として背景に表示するフォールバック機能を実装。

8.  **パフォーマンス改善（APIキャッシュ）**
    -   初回起動時やキャッシュ未存在時のみSteam Web APIからゲーム詳細情報を取得し、`electron-store`にキャッシュする仕組みを実装。
    -   2回目以降の起動時や、キャッシュ済みのゲームについては、API呼び出しをスキップし、高速に情報を読み込むように変更。
    -   ユーザーが手動でキャッシュをクリアし、ゲームリストを更新できる「ライブラリを更新」ボタンを追加。

9.  **UIのブラッシュアップ（XMB風UI）**
    -   グリッド表示とXMB表示を切り替える機能を実装。
    -   XMB表示の基盤となる`XMBView`コンポーネントを実装し、カテゴリ（横軸）とゲームリスト（縦軸）を表示。
    -   縦軸のゲームリストに代わり、3Dカルーセルエフェクトを持つ`Carousel`コンポーネントを導入。
    -   キーボード（矢印キー、WASDキー）およびマウスホイールによるXMB内のナビゲーションを実装。
    -   XMBで選択されたゲームが、動的背景に反映されるよう連携。
    -   **UIテーマ変更機能**: UIテーマを「デフォルト」と「モノトーン」で切り替える機能を実装。CSS変数を活用し、テーマ設定は`electron-store`で永続化。

10. **ゲーム管理機能（編集・削除）**
    -   手動で追加したゲームに対し、右クリックで「編集」と「削除」のコンテキストメニューを表示する機能を実装。
    -   「削除」機能は、`electron-store`からゲームデータを削除し、関連するカバーアートファイルもクリーンアップ。
    -   「編集」機能は、`AddGameModal`を編集モードで開き、ゲーム情報を更新する機能を提供。

11. **検索・フィルタリング機能**
    -   ライブラリ画面ヘッダーに検索バーUIを実装。
    -   ゲームタイトルに基づくリアルタイムな検索フィルタリングロジックを実装。

12. **堅牢性の向上と初回起動体験の改善**
    -   **初回起動チュートリアル**: 初回起動時のみ、APIキーの設定を案内するウェルカム画面を表示する機能を実装。
    -   **無効パスの通知**: 手動追加したゲームの実行ファイルパスが無効になった場合、UI上で警告を表示する機能を追加。
    -   **ネットワークエラー通知**: Steam Web APIへの接続に失敗した場合、UI右下にトースト通知でエラーを知らせる機能を実装。

13. **設定項目の拡充**
    -   設定画面に、起動時のデフォルト表示モード（グリッド or XMB）を記憶するオプションを追加。

14. **オートアップデート機能**
    -   `electron-updater`を導入し、アプリケーション起動時にアップデートを自動確認するロジックを実装。
    -   `electron-builder`を導入し、GitHub Releasesを配布サーバーとして利用するためのパッケージング設定を追加。

## 4. 主なデバッグと問題解決の履歴

開発中に発生した主な問題と、その解決策を以下に記す。

-   **問題**: `vdf-parser` の型定義がなく、TypeScriptのビルドエラーが発生。
    -   **解決策**: `vdf.parse()` の戻り値を `any` 型としてアサーションすることでコンパイルをパスさせた。

-   **問題**: Viteが `tailwindcss` モジュールを見つけられず、起動に失敗。
    -   **解決策**: `renderer` ディレクトリ内で `npm install -D tailwindcss postcss autoprefixer` を実行し、Viteの実行環境に直接依存関係を追加した。

-   **問題**: `renderer` ディレクトリで `type: "module"` を使用していたため、CommonJS形式の `postcss.config.js` の読み込みに失敗。
    -   **解決策**: `postcss.config.js` と `tailwind.config.js` を `export default` を使うESM形式に修正した。

-   **問題**: 手動追加したゲームのカバーアートが `file:///` プロトコルのセキュリティ制限により表示されない。
    -   **解決策**: Electronの `protocol.handle` を使い、`local-file://` というカスタムプロトコルを登録。アプリの `userData` ディレクトリから安全に画像を供給するようにした。

-   **問題**: 手動追加したゲームの起動に失敗。
    -   **原因**: ゲームが自身のディレクトリを作業ディレクトリとして要求するため。
    -   **解決策**: `child_process.exec` を呼び出す際に、オプションで `cwd` をゲームの実行ファイルがあるディレクトリに指定した。

-   **問題**: Escape From Tarkovなど、一部のゲームはランチャー経由での起動が必須。
    -   **解決策**: ユーザーに、ゲーム本体の `.exe` ではなく、ランチャーの `.exe` を指定するように案内し、解決を確認。

-   **問題**: XMB表示に切り替えると、検索バーへの文字入力ができない。
    -   **原因**: XMBのキーボードナビゲーションが全てのキー入力を横取り（`preventDefault`）していたため。
    -   **解決策**: キー入力のイベントハンドラで、イベントの発生源が入力フィールド（`HTMLInputElement`）の場合は、ナビゲーション処理をスキップするようにした。

-   **問題**: `main.ts`のビルドエラー（`Cannot find name 'functionName'`）。
    -   **原因**: 複数回にわたる大規模なコード置換の失敗により、関数のスコープが意図せずネストされ、参照できなくなっていた。
    -   **解決策**: 部分的な修正を諦め、`main.ts`のファイル全体を、これまでのロジックをすべて含んだ正しい構造で一括上書きすることで、ファイルの整合性を回復させた。

-   **問題**: APIキーを無効にしても、キャッシュがクリアされずエラー通知が表示されない。
    -   **原因**: `electron-store`の`delete()`メソッドが期待通りに動作していなかった可能性。
    -   **解決策**: キャッシュを削除する代わりに、空のオブジェクトで上書き (`store.set('gameCache', {})`) する、より確実な方法に変更した。

-   **問題**: `getSteamPath`関数の`reg query`コマンドのパスが不正。
    -   **原因**: `main.ts`のファイル全体を書き換えた際に、レジストリパスのバックスラッシュが欠落していた。
    -   **解決策**: `reg query "HKEY_CURRENT_USER\Software\Valve\Steam"`のように、バックスラッシュをエスケープして修正した。

## 5. 未解決の問題 (解決済み)

-   **静止画の背景が表示されない**:
    -   **症状**: ビデオ付きのゲームは動的背景が正常に機能するが、ビデオがなく静止画（カバーアート）を背景として使用するゲームで、背景が表示されない。
    -   **試したこと**: `background-image` スタイルを持つ `div` から、`<img>` タグの利用、CSSクラスの調整など複数回のリファクタリングを試みた。
    -   **解決済み**: 最終的に、背景メディア用のコンテナを分離し、`<img>` タグを正しく配置する構造にリファクタリングすることで解決。CSSの描画順序とプロパティの競合が原因であった可能性が高い。

## 6. アプリケーションのビルドと配布（オートアップデート手順）

`electron-updater`によるオートアップデート機能を有効化するための詳細な手順。

### ステップ1: GitHubリポジトリの準備

1.  **新規リポジトリ作成**: GitHub上で、このプロジェクトのための新しい**パブリックリポジトリ**を作成します。（例: `gameluncher_app_ver3`）
2.  **ローカルリポジトリの初期化**:
    -   まだgitリポジトリを初期化していない場合、プロジェクトのルートディレクトリで以下のコマンドを実行します。
        ```bash
        git init
        git add .
        git commit -m "Initial commit"
        ```
3.  **リモートリポジトリの紐付け**:
    -   GitHubで作成したリポジトリのURLを、ローカルリポジトリに`origin`として登録します。（`your-username` と `your-repo-name` はご自身のものに置き換えてください）
        ```bash
        git remote add origin https://github.com/your-username/your-repo-name.git
        ```
4.  **コードのプッシュ**:
    -   現在のソースコードをGitHubにプッシュします。
        ```bash
        git push -u origin main
        ```

### ステップ2: `package.json`の更新

-   `package.json`ファイルを開き、末尾の`build`セクションを、ご自身の情報に合わせて修正します。
    -   `author`: ご自身の名前に変更します。
    -   `publish.owner`: あなたのGitHubユーザー名に書き換えます。
    -   `publish.repo`: あなたが作成したGitHubリポジトリ名に書き換えます。

    ```json
      "author": "akats", // 例
      "build": {
        // ...
        "publish": {
          "provider": "github",
          "owner": "akats", // 例
          "repo": "gameluncher_app_ver3" // 例
        }
      }
    ```

### ステップ3: 最初のバージョンのビルドとリリース

1.  **ビルドコマンドの実行**:
    -   プロジェクトのルートディレクトリで、以下のコマンドを実行します。これにより、インストール可能なファイルが生成されます。
        ```bash
        npm run dist
        ```
2.  **生成されたファイルの確認**:
    -   プロジェクト内に`release`というフォルダが作成され、その中に`.exe`インストーラーと`latest.yml`というファイルがあることを確認します。
3.  **GitHubでのリリース作成**:
    -   ブラウザでご自身のGitHubリポジトリを開き、「Releases」セクションに移動します。
    -   「Draft a new release」をクリックします。
    -   **タグを作成**: 「Choose a tag」で、`v1.0.0` のようにバージョン番号を入力し、新しいタグを作成します。
    -   **リリースノート入力**: リリースのタイトル（例: `Version 1.0.0`）や説明を入力します。
    -   **ファイルのアップロード**: `release`フォルダに生成された **`.exe`ファイル**と**`latest.yml`ファイル**の両方を、リリースのアセットとしてドラッグ＆ドロップでアップロードします。
    -   「Publish release」をクリックして、最初のバージョンを公開します。

### ステップ4: アップデートのテスト

1.  **バージョン番号の更新**:
    -   `package.json`の`version`を、`1.0.0`から`1.0.1`のように更新します。
2.  **コードの変更**:
    -   何か小さな変更をコードに加えます。（例：UIのテキストを少し変えるなど）
3.  **再度ビルド**:
    -   もう一度`npm run dist`コマンドを実行します。
4.  **新しいバージョンのリリース**:
    -   ステップ3と同様に、GitHubで新しいリリースを作成します。今度はタグを`v1.0.1`のように設定し、新しく生成された`.exe`と`latest.yml`をアップロードして公開します。

### ステップ5: 動作確認

1.  **古いバージョンをインストール**: GitHubのリリースから、**`v1.0.0`のインストーラー**をダウンロードしてPCにインストールし、アプリケーションを起動します。
2.  **アップデートの確認**: アプリケーション起動後、しばらくするとバックグラウンドでアップデートが検知・ダウンロードされます。ダウンロードが完了すると、「アップデートの準備ができました」という通知、または再起動を促すダイアログが表示されるはずです。
3.  **再起動と更新**: ダイアログの指示に従って再起動すると、アプリケーションが新しいバージョン（`v1.0.1`）に更新されていることが確認できます。
